**Inversion of Control (IoC)** là một nguyên tắc thiết kế trong lập trình hướng đối tượng nhằm giúp việc quản lý các đối tượng và phụ thuộc của chúng trở nên linh hoạt hơn. IoC cho phép các phần của chương trình không phụ thuộc chặt chẽ vào nhau mà được cấu hình và liên kết một cách động, giúp code dễ bảo trì, kiểm thử và mở rộng.

### Cách hiểu về IoC
IoC có thể được hiểu là "đảo ngược điều khiển", tức là thay vì một đối tượng tự tạo và quản lý các đối tượng phụ thuộc của nó, nhiệm vụ này được chuyển sang một đối tượng khác (như IoC container). IoC container sẽ chịu trách nhiệm tạo ra các đối tượng, quản lý vòng đời của chúng và liên kết các phụ thuộc vào với nhau.

### Ví dụ trong Spring Framework
Trong Spring Framework, IoC thường được thực hiện thông qua **Dependency Injection (DI)**. Đây là cách mà Spring container sẽ tự động cung cấp các phụ thuộc cho một đối tượng thay vì đối tượng đó tự tạo ra chúng. Có các cách tiêm phụ thuộc (DI) phổ biến như sau:

1. **Constructor Injection**:
   Các phụ thuộc được cung cấp thông qua constructor của đối tượng.
   ```java
   public class UserService {
       private UserRepository userRepository;

       // Constructor injection
       public UserService(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

2. **Setter Injection**:
   Các phụ thuộc được cung cấp thông qua setter method.
   ```java
   public class UserService {
       private UserRepository userRepository;

       // Setter injection
       public void setUserRepository(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

3. **Field Injection** (ít khuyến khích hơn):
   Các phụ thuộc được cung cấp trực tiếp vào các trường (fields) của đối tượng thông qua annotation `@Autowired`.
   ```java
   public class UserService {
       @Autowired
       private UserRepository userRepository;
   }
   ```

### Lợi ích của IoC
- **Giảm sự phụ thuộc (Loose Coupling)**: IoC tách biệt việc tạo và quản lý vòng đời của đối tượng ra khỏi bản thân các đối tượng đó, giúp các đối tượng có thể dễ dàng thay thế hoặc mở rộng mà không cần thay đổi code.
- **Tăng khả năng tái sử dụng**: Các đối tượng có thể được tái sử dụng ở nhiều nơi khác nhau vì chúng không bị ràng buộc chặt chẽ với các phụ thuộc cụ thể.
- **Dễ kiểm thử**: Với IoC, các phụ thuộc có thể dễ dàng được thay thế bằng các đối tượng giả lập (mock objects) khi kiểm thử, giúp viết unit test dễ dàng hơn.

### Tổng kết
IoC là một nguyên tắc quan trọng giúp cho việc phát triển phần mềm trở nên linh hoạt và dễ bảo trì hơn. Trong các framework như Spring, IoC là một trong những yếu tố cốt lõi để xây dựng các ứng dụng theo mô hình lập trình hướng đối tượng, giúp quản lý các phụ thuộc một cách hiệu quả thông qua các container và cơ chế Dependency Injection.





**Dependency Injection (DI)** là một mẫu thiết kế trong lập trình hướng đối tượng, được sử dụng để thực hiện **Inversion of Control (IoC)**. Nó cho phép một đối tượng nhận các phụ thuộc của mình từ một nguồn bên ngoài thay vì tự tạo ra, giúp cho mã nguồn trở nên linh hoạt hơn, dễ bảo trì và dễ kiểm thử hơn.

### Dependency Injection hoạt động như thế nào?
Trong DI, trách nhiệm tạo ra và quản lý các phụ thuộc được ủy thác cho một thành phần bên ngoài (thường được gọi là **container**). Container này cung cấp các phụ thuộc cần thiết cho đối tượng, giúp đối tượng có thể tập trung vào các chức năng chính của mình thay vì phải quản lý cách các phụ thuộc được tạo ra.

### Các loại Dependency Injection
Có ba loại chính của DI:

1. **Constructor Injection**: Các phụ thuộc được truyền vào đối tượng thông qua constructor (hàm khởi tạo).
2. **Setter Injection**: Các phụ thuộc được truyền vào thông qua các phương thức setter.
3. **Field Injection**: Các phụ thuộc được gán trực tiếp vào các biến của đối tượng, thường sử dụng annotation (chỉ thị) như `@Autowired` trong Spring.

### Lợi ích của Dependency Injection
- **Giảm độ kết dính (Coupling)**: DI giúp giảm sự phụ thuộc của các lớp vào nhau, giúp mã nguồn dễ thay đổi và mở rộng.
- **Dễ kiểm thử (Testable)**: Với DI, ta có thể dễ dàng thay thế các phụ thuộc bằng các mock object hoặc stub khi kiểm thử.
- **Tái sử dụng mã nguồn**: Bằng cách tách biệt các phụ thuộc, các lớp có thể được tái sử dụng trong các ngữ cảnh khác nhau mà không cần sửa đổi.

DI thường được sử dụng trong các framework như **Spring** để quản lý sự phụ thuộc giữa các bean, giúp ứng dụng trở nên dễ bảo trì và phát triển.








@Component là một annotation trong Spring Framework được sử dụng để đánh dấu một class là một Spring bean. Khi một class được đánh dấu với @Component, Spring sẽ tự động phát hiện và quản lý nó như một bean trong container của Spring. Điều này cho phép Spring thực hiện dependency injection và quản lý vòng đời của bean đó.




@SpringBootApplication là một annotation trong Spring Boot, được sử dụng để đánh dấu một class là một Spring Boot application.
Annotation này kết hợp nhiều annotation khác như @Configuration, @EnableAutoConfiguration, @ComponentScan để cung cấp các cấu
hình mặc định cho ứng dụng Spring Boot. Khi một class được đánh dấu với @SpringBootApplication, Spring Boot sẽ tự động cấu hình và khởi tạo ứng dụng dựa trên các cấu hình mặc định và các bean được quản lý trong container của Spring.



@EnableAutoConfiguration
@EnableAutoConfiguration là một annotation trong Spring Boot, được sử dụng để tự động cấu hình Spring application dựa trên các dependencies mà bạn đã thêm vào pom.xml hoặc build.gradle. Annotation này giúp Spring Boot tự động cấu hình các bean cần thiết mà không cần phải cấu hình thủ công.
@ComponentScan
@ComponentScan là một annotation trong Spring Framework, được sử dụng để quét các package cụ thể để tìm và đăng ký các bean với Spring container. Annotation này giúp Spring tìm kiếm các class được đánh dấu với @Component, @Service, @Repository, và @Controller để quản lý chúng như các bean.
@Configuration
@Configuration là một annotation trong Spring Framework, được sử dụng để đánh dấu một class là một nguồn cấu hình cho Spring IoC container. Class được đánh dấu với @Configuration có thể chứa các phương thức được đánh dấu với @Bean để định nghĩa các bean.



Trong Dependency Injection (DI), **setter injection** và **constructor injection** là hai phương pháp phổ biến để cung cấp các phụ thuộc cho đối tượng. Mỗi loại đều có ưu và nhược điểm riêng, phù hợp với các tình huống khác nhau. Dưới đây là sự khác biệt và cách sử dụng của từng loại:

### 1. Constructor Injection
**Constructor Injection** là cách truyền các phụ thuộc cho đối tượng thông qua constructor (hàm khởi tạo). Điều này có nghĩa là các phụ thuộc cần thiết sẽ được cung cấp tại thời điểm tạo đối tượng thông qua các tham số của constructor.

**Ví dụ:**

```java
public class UserService {
    private final UserRepository userRepository;

    // Inject UserRepository thông qua constructor
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

Trong ví dụ trên, `UserService` nhận `UserRepository` như một phụ thuộc thông qua constructor. Khi tạo một instance của `UserService`, ta phải cung cấp một `UserRepository` hợp lệ.

**Ưu điểm:**
- **An toàn hơn**: Các phụ thuộc được cung cấp ngay khi đối tượng được tạo ra, giúp đảm bảo đối tượng luôn có đầy đủ các phụ thuộc cần thiết.
- **Dễ test hơn**: Do các phụ thuộc được cung cấp qua constructor, việc mock (giả lập) các đối tượng trong quá trình kiểm thử sẽ trở nên đơn giản.
- **Đơn giản hóa logic**: Vì các phụ thuộc là `final`, ta biết chắc rằng chúng sẽ không bị thay đổi sau khi được thiết lập.

**Nhược điểm:**
- Nếu đối tượng có quá nhiều phụ thuộc, constructor sẽ có quá nhiều tham số, làm mã nguồn trở nên khó đọc và quản lý.

### 2. Setter Injection
**Setter Injection** là cách truyền các phụ thuộc thông qua các phương thức setter. Thay vì cung cấp phụ thuộc ngay khi khởi tạo đối tượng, ta có thể thiết lập các phụ thuộc sau khi đối tượng được tạo ra.

**Ví dụ:**

```java
public class UserService {
    private UserRepository userRepository;

    // Inject UserRepository thông qua setter
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

Trong ví dụ trên, `UserService` có một phương thức `setUserRepository` để nhận `UserRepository` như một phụ thuộc.

**Ưu điểm:**
- **Linh hoạt hơn**: Cho phép thay đổi các phụ thuộc sau khi đối tượng được tạo ra, hữu ích trong các tình huống khi phụ thuộc có thể thay đổi sau này.
- **Đơn giản với ít phụ thuộc**: Nếu đối tượng chỉ có một vài phụ thuộc, việc sử dụng setter có thể làm cho mã nguồn dễ đọc hơn.

**Nhược điểm:**
- **Không đảm bảo đầy đủ phụ thuộc**: Vì các phụ thuộc được thiết lập sau khi đối tượng được tạo ra, có thể xảy ra tình trạng các phụ thuộc chưa được thiết lập trước khi sử dụng, dẫn đến lỗi runtime.
- **Phức tạp hơn khi kiểm thử**: Khi kiểm thử, cần chú ý thiết lập đầy đủ các phụ thuộc trước khi sử dụng đối tượng, nếu không sẽ gây lỗi.

### Khi nào nên dùng Constructor Injection hay Setter Injection?
- **Constructor Injection**: Thích hợp khi phụ thuộc là bắt buộc để đối tượng hoạt động. Nếu một phụ thuộc mà không có sẽ làm đối tượng hoạt động không chính xác, thì nên dùng constructor injection.
- **Setter Injection**: Thích hợp cho các phụ thuộc tùy chọn hoặc khi cần thay đổi phụ thuộc trong quá trình chạy của ứng dụng.

Trong thực tế, kết hợp cả hai cách này cũng khá phổ biến, sử dụng constructor injection cho các phụ thuộc bắt buộc và setter injection cho các phụ thuộc tùy chọn.





@Primary là một annotation trong Spring Framework, được dùng để chỉ định bean ưu tiên khi có nhiều bean cùng loại (cùng kiểu) trong Spring Container. Annotation này giúp Spring quyết định sẽ inject bean nào khi có nhiều lựa chọn.

Khi nào dùng @Primary?
Khi bạn có nhiều bean cùng kiểu và cần chỉ định một trong số đó làm bean mặc định, bạn có thể sử dụng @Primary để cho Spring biết đâu là lựa chọn ưu tiên:

Nếu bạn không dùng @Primary, Spring sẽ không biết phải inject bean nào trong số các bean có cùng kiểu và sẽ xảy ra lỗi NoUniqueBeanDefinitionException.
@Primary giúp bạn giảm thiểu việc phải sử dụng @Qualifier cho các trường hợp đơn giản, vì nó tự động ưu tiên bean được đánh dấu.

@Qualifier has higher priority than @Primary
should use @Qualifier when you have multiple beans of the same type and want to specify which one to inject.





@Lazy is an annotation in Spring Framework used to indicate that a bean should be lazily initialized
This means that the bean will not be created until it is first requested.
By default, Spring beans are eagerly initialized when the application context is created.
However, using @Lazy allows you to defer the initialization of a bean until it is actually needed.

When to use @Lazy?







Tóm tắt các loại Bean Scopes trong Spring:
Scope	        Mô tả	                                            Phạm vi sử dụng
singleton	    Một instance duy nhất trong container.	            Ứng dụng chung.
prototype	    Tạo một instance mới mỗi khi yêu cầu bean.	        Ứng dụng chung.
request	        Tạo một instance mới cho mỗi HTTP request.	        Chỉ dùng trong ứng dụng web.
session	        Tạo một instance mới cho mỗi HTTP session.	        Chỉ dùng trong ứng dụng web.
application	    Tạo một instance mới cho mỗi ServletContext.	    Chỉ dùng trong ứng dụng web.
websocket	    Tạo một instance mới cho mỗi phiên WebSocket.	    Chỉ dùng trong ứng dụng có WebSocket.

Khi nào nên sử dụng từng loại scope?
Sử dụng singleton khi bạn chỉ cần một instance cho toàn bộ ứng dụng, giúp tiết kiệm bộ nhớ và quản lý dễ dàng hơn.
Sử dụng prototype khi bạn cần nhiều đối tượng độc lập (ví dụ: các đối tượng thay đổi theo thời gian).
Sử dụng request và session khi làm việc với ứng dụng web và cần quản lý trạng thái dựa trên các yêu cầu hoặc phiên người dùng.
application thường được dùng khi bạn cần chia sẻ dữ liệu hoặc cấu hình trong toàn bộ ứng dụng web.







Bean trong Spring là một đối tượng được quản lý bởi Spring Container. Khi bạn viết một ứng dụng sử dụng Spring, bạn có thể khai báo các đối tượng (class) và yêu cầu Spring tạo ra và quản lý các đối tượng này cho bạn. Những đối tượng này chính là các Bean.

Cách hiểu đơn giản về Bean:
Giống như các thành phần trong nhà bếp:

Hãy tưởng tượng bạn có một nhà bếp (Spring Container) và bạn muốn nấu ăn.
Bạn cần các nguyên liệu như gạo, rau, thịt, v.v.
Mỗi nguyên liệu này giống như một Bean.
Bạn không cần phải đi ra ngoài và mua các nguyên liệu này mỗi khi bạn nấu ăn. Thay vào đó, bạn yêu cầu người trợ lý nhà bếp (Spring) cung cấp nguyên liệu từ nhà kho.
Người trợ lý này sẽ lấy đúng nguyên liệu cho bạn (dựa trên cách bạn yêu cầu) và đưa cho bạn.
Bean là các đối tượng được Spring tạo ra và quản lý:

Khi bạn khai báo một class trong Spring và đánh dấu nó là một Bean (bằng cách sử dụng các annotation như @Component, @Service, @Repository, hoặc @Bean), Spring sẽ biết rằng cần phải tạo ra một instance của class này và lưu trữ nó trong Spring Container.
Khi bạn cần sử dụng đối tượng này trong các phần khác của ứng dụng, Spring sẽ tự động inject (đưa vào) nó cho bạn, dựa trên các yêu cầu mà bạn chỉ định.



Các bước trong Bean Lifecycle:
Instantiation (Tạo đối tượng):

Khi Spring Container khởi động, nó sẽ tạo một instance của Bean dựa trên cấu hình (annotation hoặc XML).
Populate Properties (Gán giá trị cho thuộc tính):

Sau khi Bean được tạo ra, Spring sẽ gán giá trị cho các thuộc tính của Bean (ví dụ, inject các Bean khác hoặc giá trị cơ bản).
@PostConstruct (Initialization Callback):

Nếu Bean của bạn có phương thức được đánh dấu bằng @PostConstruct, Spring sẽ gọi phương thức này sau khi hoàn thành việc gán giá trị cho các thuộc tính.
Đây là nơi bạn có thể thực hiện các thiết lập cần thiết cho Bean trước khi sử dụng.
afterPropertiesSet() (InitializingBean Interface):

Nếu Bean của bạn triển khai InitializingBean và có phương thức afterPropertiesSet(), Spring sẽ gọi phương thức này sau khi hoàn tất giai đoạn gán thuộc tính.
Bạn có thể dùng phương thức này để khởi tạo thêm, nhưng việc này không phổ biến bằng việc dùng @PostConstruct.
Custom Init Method (Phương thức khởi tạo tùy chỉnh):

Bạn cũng có thể chỉ định một phương thức khởi tạo tùy chỉnh bằng cách sử dụng thuộc tính init-method trong cấu hình XML hoặc @Bean(initMethod = "yourInitMethod") trong cấu hình Java.
Phương thức này sẽ được gọi sau khi các bước khởi tạo mặc định đã hoàn thành.
Bean is Ready to Use (Bean đã sẵn sàng để sử dụng):

Sau khi hoàn thành các bước trên, Bean đã sẵn sàng để sử dụng trong ứng dụng.
Ứng dụng có thể gọi các phương thức của Bean bất cứ lúc nào.
@PreDestroy (Destruction Callback):

Khi Spring Container bị đóng (ví dụ, khi ứng dụng kết thúc hoặc bạn gọi context.close()), nếu Bean của bạn có phương thức được đánh dấu bằng @PreDestroy, Spring sẽ gọi phương thức này trước khi hủy Bean.
Đây là nơi bạn thực hiện các thao tác dọn dẹp, như đóng kết nối hoặc giải phóng tài nguyên.
destroy() (DisposableBean Interface):

Nếu Bean của bạn triển khai DisposableBean và có phương thức destroy(), Spring sẽ gọi phương thức này trong giai đoạn hủy.
Phương thức này thường được dùng để dọn dẹp tài nguyên.
Custom Destroy Method (Phương thức hủy tùy chỉnh):

Bạn có thể định nghĩa phương thức hủy tùy chỉnh với thuộc tính destroy-method trong cấu hình XML hoặc @Bean(destroyMethod = "yourDestroyMethod") trong cấu hình Java.
Phương thức này sẽ được gọi trước khi Bean bị loại bỏ hoàn toàn.




@Bean là một annotation trong Spring Framework, thường được sử dụng trong các lớp cấu hình (@Configuration) để định nghĩa một Bean. Khi bạn sử dụng @Bean, bạn đang tạo ra một đối tượng và yêu cầu Spring quản lý nó như một Bean trong Spring Container. Các Bean này sẽ được Spring khởi tạo, quản lý vòng đời, và có thể được inject vào các thành phần khác trong ứng dụng.

Khi nào sử dụng @Bean?
@Bean thường được dùng trong các trường hợp sau:

Cấu hình thủ công: Khi bạn muốn tạo một đối tượng (Bean) nhưng không thể hoặc không muốn dùng các annotation khác như @Component, @Service, hoặc @Repository.
Khởi tạo phức tạp: Khi quá trình khởi tạo Bean cần có logic phức tạp hơn chỉ là việc dùng constructor hoặc setter.
Bean của bên thứ ba: Khi bạn cần khởi tạo các đối tượng từ các thư viện bên ngoài mà bạn không thể thêm annotation vào lớp đó.







Hibernate/JPA
So sánh nhanh giữa ba công nghệ:
Tiêu chí	        JDBC	                                                                                            JPA	                Hibernate
Mức độ	            API cơ bản	                                                                                        API tiêu chuẩn	Framework ORM triển khai JPA
Kiểm soát	        Hoàn toàn kiểm soát các câu lệnh SQL	Tự động ánh xạ và giảm bớt việc viết SQL	Ánh xạ tự động, tính năng nâng cao như cache
Code	            Dài, phức tạp	Ngắn gọn hơn nhờ các annotation	Tương tự JPA, cung cấp thêm các tính năng đặc biệt
Khả năng bảo trì	Khó bảo trì với ứng dụng lớn	Dễ bảo trì hơn nhờ ánh xạ đối tượng	Dễ bảo trì, cộng đồng lớn và nhiều tài liệu
Cấu hình	        Đơn giản	Phức tạp hơn vì cần ánh xạ đối tượng	Phức tạp nhất do có nhiều tùy chọn cấu hình
Kết luận:
JDBC: Phù hợp khi bạn cần toàn quyền kiểm soát các truy vấn SQL và xử lý dữ liệu theo cách riêng, hoặc khi bạn cần truy cập dữ liệu nhanh và hiệu suất là ưu tiên hàng đầu.
JPA: Hữu ích khi bạn muốn đơn giản hóa việc ánh xạ dữ liệu giữa các đối tượng Java và bảng trong CSDL, làm cho mã dễ đọc và dễ bảo trì hơn.
Hibernate: Lựa chọn tốt khi bạn muốn sử dụng đầy đủ các tính năng của JPA và cần các tính năng nâng cao mà Hibernate cung cấp, như caching và quản lý các mối quan hệ phức tạp.



Ý nghĩa của CRUD trong phát triển phần mềm:
CRUD rất quan trọng vì nó đại diện cho những hành động cơ bản cần thiết khi quản lý dữ liệu trong bất kỳ ứng dụng nào, từ web, mobile đến desktop.
Khi bạn tạo một API hoặc dịch vụ web, thường bạn sẽ tạo các điểm cuối (endpoints) để thực hiện các thao tác CRUD này.
Ví dụ: Một RESTful API có thể có các endpoint như sau:
POST /users: Tạo mới một người dùng (Create).
GET /users: Lấy danh sách người dùng (Read).
PUT /users/{id}: Cập nhật thông tin người dùng (Update).
DELETE /users/{id}: Xóa một người dùng (Delete).














	@Bean
	public CommandLineRunner commandLineRunner(String[] args) {
		return runner -> {
			System.out.println("Hello, Spring Boot!");
		};

explaination:
Trong đoạn mã trên, phương thức `commandLineRunner` được đánh dấu với annotation `@Bean` trong một ứng dụng Spring Boot. Đây là những gì phương thức này thực hiện và ý nghĩa của từng phần:

### Giải thích từng phần:

1. **Annotation `@Bean`**:
   - Annotation `@Bean` được sử dụng để đánh dấu một phương thức trong lớp cấu hình của Spring (trong trường hợp này là lớp `TheSecondApplication`). Phương thức được đánh dấu với `@Bean` sẽ trả về một đối tượng, và đối tượng này sẽ được Spring quản lý và đưa vào trong context (còn được gọi là "Spring container").
   - Khi Spring Boot khởi động, nó sẽ gọi phương thức này để tạo ra một bean (một đối tượng được quản lý bởi Spring).

2. **`CommandLineRunner`**:
   - `CommandLineRunner` là một interface trong Spring Boot, có một phương thức duy nhất là `run()`. Khi ứng dụng Spring Boot hoàn tất việc khởi tạo, nó sẽ tự động gọi phương thức `run()` của tất cả các beans thuộc loại `CommandLineRunner`.
   - `CommandLineRunner` thường được dùng để thực hiện một số tác vụ ngay sau khi ứng dụng khởi động, như khởi tạo dữ liệu, kiểm tra kết nối hoặc thực hiện một số logic cần thiết trước khi ứng dụng chính thức chạy.

3. **`commandLineRunner(String[] args)`**:
   - Ở đây, `commandLineRunner` là một phương thức trả về một `CommandLineRunner` và sử dụng cú pháp lambda (`runner -> {...}`).
   - `String[] args` là các tham số được truyền vào từ dòng lệnh khi khởi động ứng dụng (các tham số này cũng được chuyển vào phương thức `main()`).

4. **`return runner -> { System.out.println("Hello, Spring Boot!"); };`**:
   - Đây là một biểu thức lambda, tạo ra một `CommandLineRunner` với hành động cụ thể bên trong `run()`.
   - Khi `CommandLineRunner` này được thực thi, nó sẽ in ra dòng chữ `"Hello, Spring Boot!"`.
   - Việc sử dụng biểu thức lambda giúp đoạn mã ngắn gọn và dễ đọc hơn. Nó tương đương với việc viết một class riêng lẻ để triển khai `CommandLineRunner`.

### Tổng kết lại:

- Khi ứng dụng Spring Boot này khởi động, nó sẽ tìm kiếm tất cả các beans loại `CommandLineRunner` trong context.
- Sau khi khởi động hoàn tất, Spring Boot sẽ gọi phương thức `run()` của `CommandLineRunner` này.
- Kết quả là ứng dụng sẽ in ra dòng `"Hello, Spring Boot!"` ngay khi ứng dụng khởi động thành công.

### Tại sao dùng `CommandLineRunner`:

- `CommandLineRunner` thường được sử dụng để thực hiện các hành động khi ứng dụng vừa mới khởi động. Điều này có thể hữu ích để:
  - Chạy các tác vụ kiểm tra.
  - Khởi tạo một số dữ liệu mặc định.
  - Kiểm tra kết nối đến các dịch vụ khác.
  - Thực hiện các thao tác mà chỉ cần chạy một lần khi ứng dụng khởi động.

Với cách viết này, Spring Boot sẽ tự động quản lý việc gọi `run()` và bạn không cần phải lo lắng về việc tự gọi nó.







as mentioned, hibernate is the default implementation of JPA, so you can use JPA without hibernate, but you can't use hibernate without JPA.


**Entity class** trong Java và các ứng dụng sử dụng JPA (Java Persistence API) là một lớp (class) biểu diễn một bảng (table) trong cơ sở dữ liệu. Mỗi đối tượng (instance) của lớp này tương ứng với một dòng (record) trong bảng.

### Giải thích về Entity Class:

- **Annotation `@Entity`**:
  - Để khai báo một lớp là một entity (thực thể), bạn cần sử dụng annotation `@Entity` trên lớp đó. Annotation này cho JPA biết rằng lớp này sẽ ánh xạ (map) đến một bảng trong cơ sở dữ liệu.
  - Ví dụ:
    ```java
    import javax.persistence.Entity;
    import javax.persistence.Id;

    @Entity
    public class User {
        @Id
        private Long id;
        private String name;
        private String email;

        // Getters, setters, constructors, etc.
    }
    ```
    Trong ví dụ trên, lớp `User` được khai báo là một entity.

- **Mapping giữa các thuộc tính và cột**:
  - Mỗi thuộc tính (field) trong entity class tương ứng với một cột (column) trong bảng cơ sở dữ liệu.
  - Ví dụ, trong lớp `User`, các thuộc tính `id`, `name`, và `email` sẽ ánh xạ đến các cột `id`, `name`, và `email` trong bảng `User`.

- **`@Id` annotation**:
  - Annotation `@Id` được sử dụng để chỉ định thuộc tính nào sẽ là khóa chính (primary key) của bảng. Đây là trường duy nhất xác định một dòng trong bảng.
  - Ví dụ, `@Id` trong lớp `User` chỉ định rằng `id` là khóa chính của bảng `User`.

### Một số annotation phổ biến khác khi làm việc với Entity:

- **`@Table`**:
  - Mặc định, tên của bảng sẽ giống với tên của lớp. Tuy nhiên, bạn có thể dùng `@Table` để tùy chỉnh tên bảng.
  - Ví dụ:
    ```java
    @Entity
    @Table(name = "users_table")
    public class User { ... }
    ```
    Trong ví dụ này, lớp `User` sẽ ánh xạ đến bảng có tên là `users_table`.

- **`@Column`**:
  - Mặc định, tên của cột sẽ giống với tên của thuộc tính trong class. Bạn có thể dùng `@Column` để tùy chỉnh tên cột, độ dài, kiểu dữ liệu, hoặc các thuộc tính khác của cột.
  - Ví dụ:
    ```java
    @Column(name = "user_name", length = 50)
    private String name;
    ```
    Thuộc tính `name` sẽ ánh xạ đến cột `user_name` với độ dài tối đa là 50 ký tự.

### Entity Class trong JPA giúp gì?

1. **ORM (Object-Relational Mapping)**:
   - Entity class là một phần của cơ chế ORM, nơi mà các đối tượng Java (class) được ánh xạ với các bảng trong cơ sở dữ liệu. Điều này giúp lập trình viên có thể làm việc với dữ liệu dưới dạng đối tượng mà không cần viết các truy vấn SQL phức tạp.
   - Khi bạn thực hiện các thao tác trên đối tượng Java (như thêm, sửa, xóa), JPA sẽ tự động chuyển các thao tác này thành các câu lệnh SQL tương ứng.

2. **Tạo sự liên kết giữa các bảng**:
   - Entity class cũng có thể chứa các mối quan hệ giữa các bảng như `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany` để mô tả các liên kết (relationship) giữa các thực thể.

### Tóm lại:

- **Entity class** là một lớp Java được đánh dấu với `@Entity` và được sử dụng để ánh xạ với một bảng trong cơ sở dữ liệu.
- Nó giúp lập trình viên làm việc với cơ sở dữ liệu một cách dễ dàng hơn thông qua các đối tượng Java, giảm thiểu việc viết các truy vấn SQL thủ công và giúp mã dễ đọc, dễ bảo trì hơn.





if you dont declare any constructors, java will provide a no-argument constructor for free


### 1. `@Column` trong JPA:

`@Column` là một annotation được sử dụng để chỉ định cách một thuộc tính (field) của entity sẽ ánh xạ đến một cột trong bảng cơ sở dữ liệu. Nó cung cấp các tùy chọn để tùy chỉnh tên cột, độ dài, kiểu dữ liệu, và các thuộc tính khác của cột.

#### Các thuộc tính của `@Column`:
- **`name`**: Đặt tên của cột trong bảng. Nếu không được chỉ định, tên cột sẽ mặc định là tên của thuộc tính.
- **`length`**: Độ dài của cột. Thường sử dụng cho các thuộc tính kiểu `String`.
- **`nullable`**: Chỉ định liệu cột có cho phép `null` hay không. Mặc định là `true`.
- **`unique`**: Chỉ định liệu giá trị trong cột có phải là duy nhất hay không.
- **`columnDefinition`**: Định nghĩa kiểu dữ liệu của cột.
- **`insertable` / `updatable`**: Chỉ định liệu cột này có được phép ghi (insert) hay cập nhật (update) hay không.

#### Ví dụ:
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name", length = 100, nullable = false)
    private String name;

    @Column(unique = true)
    private String email;

    // Getters, setters, etc.
}
```
- Ở ví dụ trên, thuộc tính `name` ánh xạ tới cột `user_name` trong bảng với độ dài tối đa là 100 và không cho phép giá trị `null`.
- Thuộc tính `email` được ánh xạ đến một cột có các giá trị duy nhất.

### 2. `@Table` trong JPA:

`@Table` là một annotation được sử dụng trên lớp entity để chỉ định tên của bảng mà entity sẽ ánh xạ đến. Mặc định, tên của bảng sẽ giống với tên của lớp, nhưng bạn có thể thay đổi tên bảng và một số thuộc tính khác bằng cách sử dụng `@Table`.

#### Các thuộc tính của `@Table`:
- **`name`**: Đặt tên của bảng.
- **`schema`**: Chỉ định schema mà bảng thuộc về (nếu có).
- **`catalog`**: Chỉ định catalog của bảng (nếu có).
- **`uniqueConstraints`**: Định nghĩa các ràng buộc duy nhất (unique constraints) trên bảng.
- **`indexes`**: Định nghĩa các index trên bảng.

#### Ví dụ:
```java
@Entity
@Table(name = "users_table")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name", length = 100)
    private String name;

    @Column(unique = true)
    private String email;

    // Getters, setters, etc.
}
```
- Ở ví dụ trên, lớp `User` sẽ ánh xạ đến bảng có tên là `users_table` thay vì mặc định là `User`.

### 3. `GenerationType.IDENTITY`:

`GenerationType.IDENTITY` là một chiến lược tạo khóa chính (primary key) tự động cho các cột được đánh dấu là `@Id` trong JPA. Nó cho phép cơ sở dữ liệu tự động sinh ra giá trị cho cột khóa chính khi một bản ghi mới được thêm vào.

#### Chi tiết về `GenerationType.IDENTITY`:
- **Sử dụng cho các cột tự tăng (auto-increment)**:
  - Với `GenerationType.IDENTITY`, giá trị của khóa chính sẽ được tự động tăng lên dựa trên giá trị cao nhất hiện tại trong cơ sở dữ liệu.
  - Điều này hữu ích khi bạn muốn sử dụng tính năng tự động tăng (`AUTO_INCREMENT`) có sẵn của cơ sở dữ liệu.

- **Hoạt động**: Khi thêm một bản ghi mới vào bảng, bạn không cần phải chỉ định giá trị cho trường ID, cơ sở dữ liệu sẽ tự động sinh ra giá trị tiếp theo.

#### Ví dụ:
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name")
    private String name;

    // Getters, setters, etc.
}
```
- Ở ví dụ này, trường `id` sẽ được tự động sinh giá trị bởi cơ sở dữ liệu khi thêm mới bản ghi vào bảng `User`.

#### Tóm tắt các chiến lược sinh ID khác:
- **`GenerationType.AUTO`**: JPA sẽ tự động chọn chiến lược sinh ID phù hợp nhất với cơ sở dữ liệu đang sử dụng.
- **`GenerationType.SEQUENCE`**: Sử dụng một sequence để tạo giá trị cho khóa chính (thường dùng với cơ sở dữ liệu như PostgreSQL).
- **`GenerationType.TABLE`**: Sử dụng một bảng riêng trong cơ sở dữ liệu để tạo giá trị cho khóa chính (ít phổ biến hơn).

### Tóm lại:

- **`@Column`** giúp tùy chỉnh các thuộc tính của cột trong bảng khi ánh xạ từ một thuộc tính của entity.
- **`@Table`** giúp tùy chỉnh tên bảng và các đặc tính khác của bảng mà entity sẽ ánh xạ đến.
- **`GenerationType.IDENTITY`** cho phép cơ sở dữ liệu tự động tạo ra giá trị cho các khóa chính tự tăng, giúp dễ dàng quản lý các giá trị ID mà không cần tự tạo ra chúng.







DAO(Data Access Object)
### 1. `EntityManager` là gì?

`EntityManager` là một API của JPA (Java Persistence API) dùng để quản lý các thực thể (entities) và các thao tác với cơ sở dữ liệu. Nó cung cấp các phương thức cơ bản để thao tác với các thực thể như thêm (persist), cập nhật (merge), xóa (remove), và truy vấn (query) dữ liệu.

#### Các chức năng chính của `EntityManager`:
- **Persist**: Lưu một thực thể vào cơ sở dữ liệu.
- **Merge**: Đồng bộ hóa (merge) một thực thể đã thay đổi với thực thể đã lưu trữ trong cơ sở dữ liệu.
- **Remove**: Xóa một thực thể khỏi cơ sở dữ liệu.
- **Find**: Tìm kiếm một thực thể dựa trên khóa chính.
- **Query**: Tạo các câu truy vấn (JPQL - Java Persistence Query Language).

#### Ví dụ:
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    // Getters, setters, etc.
}

// Sử dụng EntityManager
@Autowired
private EntityManager entityManager;

public void saveUser(User user) {
    entityManager.persist(user); // Lưu user vào cơ sở dữ liệu
}

public User findUser(Long id) {
    return entityManager.find(User.class, id); // Tìm user theo id
}

public void deleteUser(User user) {
    entityManager.remove(user); // Xóa user khỏi cơ sở dữ liệu
}
```

#### Khi nào sử dụng `EntityManager`?
- Khi bạn cần **kiểm soát chi tiết** quá trình xử lý dữ liệu và muốn tự viết các phương thức lưu, cập nhật, xóa.
- Khi cần làm việc với các **giao dịch** (transactions) phức tạp và cần tùy chỉnh các thao tác giao dịch.
- Khi sử dụng **JPQL** hoặc **Native Queries** để tạo các truy vấn phức tạp.

### 2. `JpaRepository` là gì?

`JpaRepository` là một interface thuộc Spring Data JPA, mở rộng từ `CrudRepository` và `PagingAndSortingRepository`. Nó cung cấp sẵn các phương thức CRUD (Create, Read, Update, Delete) cũng như các phương thức tìm kiếm, phân trang, sắp xếp mà không cần phải tự viết các câu lệnh.

#### Các chức năng chính của `JpaRepository`:
- **save()**: Lưu hoặc cập nhật một thực thể.
- **findById()**: Tìm thực thể theo ID.
- **findAll()**: Tìm tất cả các thực thể.
- **delete()**: Xóa một thực thể.
- **count()**: Đếm số lượng thực thể.
- **Paging and Sorting**: Hỗ trợ các thao tác phân trang và sắp xếp.

#### Ví dụ:
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    // Getters, setters, etc.
}

public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByName(String name); // Tìm kiếm theo tên
}

// Sử dụng JpaRepository
@Autowired
private UserRepository userRepository;

public void saveUser(User user) {
    userRepository.save(user); // Lưu hoặc cập nhật user
}

public User findUser(Long id) {
    return userRepository.findById(id).orElse(null); // Tìm user theo id
}

public void deleteUser(User user) {
    userRepository.delete(user); // Xóa user khỏi cơ sở dữ liệu
}

public List<User> findByName(String name) {
    return userRepository.findByName(name); // Tìm user theo tên
}
```

#### Khi nào sử dụng `JpaRepository`?
- Khi bạn muốn **đơn giản hóa thao tác CRUD** và không cần phải viết quá nhiều mã lệnh.
- Khi yêu cầu chỉ cần thực hiện các **truy vấn đơn giản** hoặc các truy vấn đã có sẵn trong `JpaRepository`.
- Khi cần **phân trang** (pagination) và **sắp xếp** dữ liệu một cách dễ dàng.

### 3. Sự khác nhau giữa `EntityManager` và `JpaRepository`:
| **Đặc điểm** | **EntityManager** | **JpaRepository** |
|--------------|-------------------|-------------------|
| **Bản chất** | Là API gốc của JPA để thao tác với các thực thể. | Là một interface của Spring Data JPA mở rộng từ `CrudRepository`. |
| **Cách sử dụng** | Cần tự viết các phương thức cho các thao tác CRUD. | Cung cấp sẵn các phương thức CRUD và có thể mở rộng để tạo các truy vấn tùy chỉnh. |
| **Kiểm soát chi tiết** | Cung cấp nhiều quyền kiểm soát hơn đối với các thao tác dữ liệu và giao dịch. | Đơn giản hóa các thao tác với ít kiểm soát hơn. |
| **Phù hợp với** | Các tác vụ phức tạp và cần kiểm soát chi tiết. | Các tác vụ đơn giản và muốn giảm thiểu mã lệnh cần viết. |

### 4. Nên sử dụng `EntityManager` hay `JpaRepository`?
- **Sử dụng `JpaRepository`**: Nếu bạn đang xây dựng các ứng dụng đơn giản, CRUD cơ bản và muốn tận dụng sự tiện lợi của Spring Data JPA để tự động hóa các thao tác với cơ sở dữ liệu.
- **Sử dụng `EntityManager`**: Khi bạn cần thực hiện các truy vấn phức tạp, cần kiểm soát quá trình xử lý giao dịch hoặc khi muốn tối ưu hóa hiệu suất của các thao tác với cơ sở dữ liệu.

Trong thực tế, bạn có thể kết hợp cả hai khi cần thiết: sử dụng `JpaRepository` cho các thao tác cơ bản và `EntityManager` cho các trường hợp cần tùy chỉnh cao hơn.




if you need low-level control and flexible use EntityManager
if you want high-level of abstraction use JPARespository



`@Transactional` là một annotation (chú thích) trong Spring Framework, được sử dụng để khai báo các phương thức hoặc các lớp cần được thực thi trong một **giao dịch** (transaction). Giao dịch là một tập hợp các thao tác với cơ sở dữ liệu được thực thi như một đơn vị logic: tất cả các thao tác phải thành công thì toàn bộ giao dịch mới được cam kết (commit); nếu một thao tác nào đó thất bại, thì toàn bộ giao dịch sẽ bị hủy bỏ (rollback).

### 1. Giao dịch (Transaction) là gì?
Giao dịch trong cơ sở dữ liệu tuân theo nguyên tắc **ACID**:
- **Atomicity** (Tính nguyên tử): Các thao tác trong giao dịch phải được thực thi như một đơn vị. Hoặc tất cả đều thành công, hoặc tất cả đều thất bại.
- **Consistency** (Tính nhất quán): Giao dịch phải duy trì trạng thái nhất quán của cơ sở dữ liệu.
- **Isolation** (Tính biệt lập): Các giao dịch phải thực thi một cách độc lập, không ảnh hưởng đến nhau.
- **Durability** (Tính bền vững): Khi một giao dịch đã được cam kết, nó phải đảm bảo dữ liệu được lưu trữ vĩnh viễn.

### 2. `@Transactional` là gì?
`@Transactional` giúp Spring quản lý các giao dịch một cách tự động. Khi chú thích một phương thức bằng `@Transactional`, Spring sẽ bắt đầu một giao dịch khi phương thức đó được gọi, và sau khi phương thức hoàn thành, Spring sẽ quyết định **commit** hoặc **rollback** giao dịch dựa trên kết quả:

- **Commit**: Nếu phương thức thực thi thành công, tất cả các thay đổi sẽ được lưu vào cơ sở dữ liệu.
- **Rollback**: Nếu có bất kỳ ngoại lệ (exception) nào xảy ra trong quá trình thực thi, Spring sẽ rollback, tức là hủy bỏ tất cả các thay đổi và khôi phục trạng thái cơ sở dữ liệu như trước khi phương thức bắt đầu.

### 3. Cách sử dụng `@Transactional`:
#### 3.1. Trên một phương thức:
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        // Nếu có exception xảy ra ở đây, thì thao tác lưu user cũng sẽ bị rollback.
    }
}
```
Trong ví dụ trên, nếu bất kỳ lỗi nào xảy ra trong quá trình tạo user, toàn bộ thay đổi trong phương thức `createUser` sẽ bị rollback.

#### 3.2. Trên một class:
```java
@Service
@Transactional
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public void createUser(User user) {
        userRepository.save(user);
    }

    public void updateUser(User user) {
        userRepository.save(user);
    }
}
```
Khi chú thích `@Transactional` ở cấp độ lớp, tất cả các phương thức trong lớp `UserService` sẽ được thực thi trong một giao dịch.

### 4. Các thuộc tính của `@Transactional`:
- **`propagation`**: Quy định cách các giao dịch mới tương tác với các giao dịch hiện tại.
  - `REQUIRED` (mặc định): Sử dụng giao dịch hiện tại nếu có, nếu không sẽ tạo mới.
  - `REQUIRES_NEW`: Luôn tạo một giao dịch mới, bất kể có giao dịch hiện tại hay không.
  - `SUPPORTS`: Nếu có giao dịch hiện tại thì sử dụng, nếu không thì chạy không cần giao dịch.
- **`isolation`**: Quy định mức độ cách ly của giao dịch, giúp kiểm soát các vấn đề như đọc bẩn, đọc lặp lại, ảo ảnh.
  - `READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`.
- **`rollbackFor`**: Quy định danh sách các ngoại lệ mà khi xảy ra, giao dịch sẽ bị rollback.
  - Ví dụ: `@Transactional(rollbackFor = Exception.class)`: Rollback cho mọi loại exception.
- **`readOnly`**: Đặt là `true` khi phương thức chỉ thực hiện các thao tác đọc, giúp tối ưu hóa hiệu suất.
  - Ví dụ: `@Transactional(readOnly = true)`: Phương thức này chỉ thực hiện các thao tác đọc dữ liệu.

### 5. Khi nào nên sử dụng `@Transactional`?
- Khi thực hiện các thao tác **thay đổi dữ liệu** (thêm, sửa, xóa) mà cần đảm bảo tính toàn vẹn và nhất quán.
- Khi bạn cần **xử lý nhiều thao tác với cơ sở dữ liệu** trong một phương thức và muốn đảm bảo rằng tất cả các thao tác đó phải thành công hoặc không có thao tác nào được áp dụng.
- Khi có yêu cầu thực hiện **các thao tác phức tạp** liên quan đến nhiều bảng hoặc liên quan đến nhiều phương thức khác nhau mà cần đảm bảo toàn vẹn dữ liệu.

### 6. Ví dụ thực tế:
```java
@Transactional
public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
    Account fromAccount = accountRepository.findById(fromAccountId).orElseThrow();
    Account toAccount = accountRepository.findById(toAccountId).orElseThrow();

    fromAccount.withdraw(amount);
    toAccount.deposit(amount);

    accountRepository.save(fromAccount);
    accountRepository.save(toAccount);
}
```
Trong ví dụ chuyển tiền giữa hai tài khoản, nếu có bất kỳ lỗi nào xảy ra (như tài khoản không đủ số dư), toàn bộ giao dịch sẽ bị rollback, và dữ liệu không bị mất mát.

### 7. Kết luận:
`@Transactional` là một công cụ mạnh mẽ trong Spring để quản lý giao dịch một cách tự động, giúp đảm bảo tính toàn vẹn và nhất quán của dữ liệu khi thực hiện các thao tác với cơ sở dữ liệu. Việc sử dụng `@Transactional` giúp giảm thiểu rủi ro lỗi dữ liệu khi có sự cố và đơn giản hóa quá trình xử lý giao dịch trong các ứng dụng doanh nghiệp.




`@Repository` là một annotation (chú thích) trong Spring Framework, được sử dụng để đánh dấu một lớp là **DAO** (Data Access Object), tức là lớp chịu trách nhiệm truy cập và tương tác với cơ sở dữ liệu.

### 1. Chức năng của `@Repository`:
- `@Repository` giúp Spring **quản lý các bean** của lớp DAO, tương tự như `@Service` hay `@Controller`. Nó giúp Spring nhận diện và tạo các đối tượng bean để quản lý các lớp này.
- `@Repository` giúp **xử lý các ngoại lệ** liên quan đến cơ sở dữ liệu. Khi được đánh dấu bằng `@Repository`, các ngoại lệ (exceptions) trong quá trình tương tác với cơ sở dữ liệu sẽ được Spring tự động chuyển đổi thành các loại ngoại lệ chung của Spring Data (như `DataAccessException`).

### 2. Khi nào sử dụng `@Repository`:
- Sử dụng `@Repository` cho các lớp chịu trách nhiệm **truy xuất dữ liệu** từ cơ sở dữ liệu, chẳng hạn như các lớp làm việc với `EntityManager`, `JDBC`, hoặc `JPA`.
- Khi bạn muốn định nghĩa một lớp quản lý các thao tác CRUD (Create, Read, Update, Delete) trên các thực thể (entities) trong cơ sở dữ liệu.

### 3. Ví dụ sử dụng `@Repository`:
#### 3.1. Sử dụng với JPA:
```java
@Repository
public class ProductRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public Product findById(Long id) {
        return entityManager.find(Product.class, id);
    }

    public void save(Product product) {
        entityManager.persist(product);
    }
}
```
Trong ví dụ trên, `ProductRepository` là một lớp được đánh dấu bằng `@Repository`, giúp Spring hiểu rằng đây là một lớp truy cập dữ liệu. Nó sử dụng `EntityManager` để thao tác với cơ sở dữ liệu.

#### 3.2. Sử dụng với Spring Data JPA:
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    List<Product> findByName(String name);
}
```
Trong ví dụ này, `ProductRepository` mở rộng `JpaRepository` và được đánh dấu bằng `@Repository`. Spring sẽ tự động cung cấp các phương thức CRUD cơ bản và các phương thức tùy chỉnh như `findByName`.

### 4. So sánh `@Repository` với `@Component`:
- `@Repository` thực chất là một kiểu chuyên biệt của `@Component`, có nghĩa là các lớp được đánh dấu bằng `@Repository` cũng là một loại bean và được quản lý bởi Spring.
- Sự khác biệt chính giữa `@Repository` và `@Component` là ở **mục đích sử dụng** và cách Spring xử lý các ngoại lệ liên quan đến truy cập cơ sở dữ liệu.
- Sử dụng `@Repository` giúp cho mã nguồn của bạn rõ ràng hơn về mặt ngữ nghĩa, dễ hiểu rằng đây là một lớp dành cho việc truy xuất dữ liệu.

### 5. Lợi ích của `@Repository`:
- Giúp **tăng tính nhất quán** trong việc quản lý các lớp truy xuất dữ liệu.
- Giúp **tự động hóa** việc xử lý các ngoại lệ liên quan đến cơ sở dữ liệu, giúp mã nguồn ngắn gọn và dễ bảo trì hơn.
- **Kết hợp tốt** với các tính năng khác của Spring như `@Transactional`, giúp quản lý giao dịch một cách dễ dàng hơn trong các phương thức thao tác với dữ liệu.

### 6. Kết luận:
`@Repository` là một annotation quan trọng trong Spring, giúp đánh dấu các lớp truy cập dữ liệu và cung cấp cho chúng các tính năng đặc biệt như xử lý ngoại lệ tự động. Việc sử dụng `@Repository` giúp phân chia rõ ràng các tầng trong ứng dụng và tăng tính dễ đọc, dễ bảo trì cho mã nguồn của bạn.







spring.jpa.hibernate.ddl-auto


none: no action
create-only: database tables are created, existing tables are not dropped
drop: database tables are dropped
create: Databases tables are created, existing tables are dropped
create-drop: same as create, but also drops tables when the SessionFactory is closed
validate: validate the schema, make no changes to the database
update: update the schema




Thuộc tính `spring.jpa.hibernate.ddl-auto` trong Spring Boot dùng để điều khiển hành vi Hibernate khi khởi tạo cơ sở dữ liệu, giúp tự động tạo hoặc cập nhật schema trong cơ sở dữ liệu. Đây là các tùy chọn và ý nghĩa của chúng:

1. **`none`**:
   - Không thực hiện bất kỳ hành động nào với cơ sở dữ liệu.
   - Hibernate sẽ không tạo, xóa, hoặc xác minh schema; chỉ chạy các truy vấn.

2. **`create-only`**:
   - Chỉ tạo bảng mới mà không xóa các bảng đã có sẵn.
   - Được dùng khi muốn tạo mới các bảng nhưng không thay đổi dữ liệu hiện có.

3. **`drop`**:
   - Xóa toàn bộ bảng hiện có trong cơ sở dữ liệu mà không tạo lại.
   - Phù hợp khi cần xóa sạch cơ sở dữ liệu nhưng không cần tái tạo bảng.

4. **`create`**:
   - Tạo bảng mới và xóa các bảng hiện có mỗi khi ứng dụng khởi động.
   - Phù hợp cho môi trường phát triển, nhưng không nên dùng trong sản xuất vì dữ liệu sẽ bị mất.

5. **`create-drop`**:
   - Giống `create`, nhưng bảng sẽ bị xóa thêm lần nữa khi ứng dụng dừng.
   - Phù hợp cho phát triển, thử nghiệm nhanh, vì dữ liệu sẽ được reset khi ứng dụng dừng.

6. **`validate`**:
   - Kiểm tra cấu trúc bảng (schema) hiện tại có khớp với các entity trong mã nguồn không.
   - Không thay đổi cơ sở dữ liệu mà chỉ báo lỗi nếu có sự khác biệt. Rất thích hợp khi cần xác minh schema trong sản xuất.

7. **`update`**:
   - Cập nhật schema nếu có thay đổi trong entity, không xóa dữ liệu.
   - Phù hợp cho môi trường phát triển và thử nghiệm, nhưng không hoàn toàn an toàn cho sản xuất vì có thể tạo ra những lỗi không mong muốn khi cập nhật schema.

Lựa chọn `validate` hoặc `none` là tối ưu nhất cho sản xuất, để tránh các thay đổi không mong muốn trong cơ sở dữ liệu.













CHAPTER 3: REST API


